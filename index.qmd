---
title: "Feature Selection: An Exploration of Algorithm Performance, Selection Bias, and Multicollinearity "
author: "Jason Case, Abhishek Dugar. Daniel Nkuah, Khoa Tran"
date: '`r Sys.Date()`'
format:
  html:
    code-fold: true
course: STA 6257 - Advanced Statistical Modeling
bibliography: references.bib # file contains bibtex for references
#always_allow_html: true # this allows to get PDF with HTML features
self-contained: true
execute: 
  warning: false
  message: false
editor: 
  markdown: 
    wrap: 72
---
# Introduction
The discipline of feature selection in machine learning has evolved significantly over the past few decades, transforming from a practice once stigmatized as "data dredging" to an essential component of modern predictive modeling. Early methods for variable selection were initially met with skepticism by the statistical community, which viewed them as potentially spurious means of uncovering patterns in data. These reservations stemmed from concerns about overfitting and the robustness of statistical inferences drawn from such techniques.
 
## Early Methods
Feature selection's early forays began with relatively simple approaches like forward, backward, and stepwise variable selection in linear models. Forward selection starts with no variables in the model, adding them one by one based on specific criteria until no significant improvement is observed. Conversely, backward selection begins with all candidate variables, removing the least significant ones iteratively. Stepwise selection combines both approaches, iteratively adding and removing variables to optimize model performance.
 
These methods were foundational but had limitations, particularly when applied to datasets with high dimensionality. For instance, @foster2004variable in their study on predicting bankruptcy highlighted the complexity of variable selection when dealing with large sets of predictors. They utilized a 20:80 train/validation split to ensure robust model evaluation and critiqued traditional criteria like the Akaike Information Criterion (AIC) for being too liberal, risking overfitting. Instead, they advocated for methods like the Bonferroni correction, which, though conservative, provided more reliable results by dynamically adjusting p-values and avoiding inflated values from high leverage points.
 
Univariate screening procedures marked another step in the evolution of feature selection. These methods involve assessing each predictor variable independently for its relationship with the target variable, selecting those that meet a certain statistical threshold. While straightforward and computationally inexpensive, univariate methods often fail to capture the complex interdependencies between variables. 
 
In the context of gene selection for cancer classification, @guyon2002gene demonstrated the limitations of univariate methods. Prior to their work, gene selection relied heavily on simple statistical measures such as correlations, which often resulted in large, redundant sets of genes. The advent of Recursive Feature Elimination (RFE) represented a significant improvement. RFE uses Support Vector Machines (SVMs) to iteratively eliminate the least important features, refining the feature set to a more relevant subset and thus enhancing model performance. This method highlighted the critical role of robust feature selection in bioinformatics, where the choice of features often influenced classification outcomes more than the specific classifier used.
 
## Modern Methods
Modern feature selection methods have become essential for data preprocessing, extracting the most important information from big data. By reducing the number of features, these methods mitigate the risk of overfitting and enhance the performance of machine learning models and pattern recognition systems [@venkatesh2019review].
 
Advanced feature selection methods include similarity-based, information-theoretical-based, sparse-learning-based, and statistical-based approaches. Similarity-based approaches select features based on their similarity or dissimilarity, while information-theoretical-based approaches use concepts like entropy and mutual information to evaluate feature importance. Sparse-learning-based approaches focus on identifying a small, essential set of features by limiting the number of features selected, and statistical-based approaches utilize statistical tests and models to determine the significance of features for predicting the target variable [@li2017feature].
 
Early and modern approaches are now categorized into filter, wrapper, embedded, and hybrid approaches. The filter model selects features based on the general properties of the training data, independent of any learning algorithm, making it computationally efficient for large datasets [@das2001filters; @kohavi1997wrappers]. Within the filter model, feature selection algorithms can be further divided into feature weighting algorithms, which assign weights to each feature based on their relevance, and subset search algorithms, which explore candidate feature subsets based on specific evaluation measures [@kohavi1997wrappers; @liu2012feature]. The wrapper model, on the other hand, uses a specific learning algorithm to evaluate and determine which features to keep, often leading to better performance but at a higher computational cost [@langley1994selection]. Embedded methods perform feature selection during the model training process, integrating selection directly with learning. Hybrid methods combine the best aspects of filter and wrapper methods to achieve optimal performance with manageable computational complexity [@venkatesh2019review; @jovic2015review].
 
Feature selection can also be divided into supervised, semi-supervised, and unsupervised categories. Supervised learning involves labeled data, semi-supervised learning utilizes both labeled and unlabeled data, and unsupervised learning works with unlabeled data. @miao2016survey emphasized that the effectiveness of feature selection methods varies depending on the dataset and model used, necessitating tailored approaches to feature selection.
 
As feature selection methods evolved, addressing multicollinearity—a scenario where predictor variables are highly correlated—became a critical focus. Traditional methods often assumed independence among features, leading to inaccurate importance measures. @basu2022multicollinearity tackled this issue by introducing a framework to adjust for feature correlations when calculating Shapley values. Their method, termed Multicollinearity Corrected (MCC) Shapley values, provided more accurate measures of feature importance by accounting for existing correlations. Their experiments on datasets with moderate to high feature correlations demonstrated the superiority of MCC Shapley values over non-corrected ones, offering a more reliable interpretation of feature importance in the presence of multicollinearity.
 
A novel feature selection algorithm leveraging neural networks aims to enhance classification accuracy while reducing computational load by selecting only the most relevant features. This method utilizes feed-forward neural networks (FFNNs) and integrates seamlessly with other classifiers. The algorithm starts with a minimal feature set and iteratively includes additional features based on their contribution to classification accuracy, ensuring that only significant features are selected [@onnia2001feature].
 
Experiments on both artificial datasets, like the Monks problems, and real-world datasets, such as the University of Wisconsin Breast Cancer Dataset, the US Congressional Voting Records Dataset, and the Pima Indians Diabetes Dataset, demonstrated significant reductions in the number of features while improving classification accuracy. This approach emphasizes the importance of feature selection in enhancing classification accuracy and reducing computational load, making it a valuable tool for various classification tasks and data collection processes.
 
In more recent developments, multiple criteria decision-making (MCDM) methods have been applied to feature selection, particularly in the context of text classification with small datasets. @kou2020evaluation evaluated various feature selection methods using MCDM techniques across multiple text classification datasets. By employing methods like PROMETHEE, they ranked feature selection techniques based on a range of performance measures, including accuracy, stability, and efficiency. Their findings underscored the importance of comprehensive evaluation criteria in selecting the most appropriate feature selection method, tailored to specific dataset characteristics.
 
The trajectory of feature selection in machine learning illustrates a progression from simple, univariate methods to sophisticated, model-based approaches that address complex issues like multicollinearity and multi-criteria decision making. Early skepticism about "data dredging" has given way to an appreciation of the nuanced techniques necessary for robust predictive modeling. Feature selection methods have evolved to include similarity-based, information-theoretical-based, sparse-learning-based, statistical-based, filter, wrapper, embedded, hybrid, supervised, semi-supervised, and unsupervised approaches. Modern methods, such as neural networks, further enhance the accuracy and efficiency of feature selection, ensuring that only the most relevant features are utilized. As the field continues to advance, it is clear that feature selection will remain a cornerstone of machine learning, improving model performance and reducing computational complexity across a wide range of applications.

## Research Methodology
Our exploration of feature selection will begin by comparing the performance of various feature selection methods on a variety of real-world datasets ([Experiment 1](#experiment-1)). We will look at four different aspects of performance: overall model performance on the holdout set, variance in performance between the training and holdout set, stability in the features selected, and parsimony of the final model. We will then examine feature selection bias of various methods by generating datasets with known parameters and determining if there is a systematic pattern to the features that are selected or omitted ([Experiment 2](#experiment-2)). Finally, we will examine the impact of multicollinearity on the feature selection process ([Experiment 3](#experiment-3)).

# Experiment 1: Performance Comparison {#experiment-1}
## Methods

## Analysis and Results

### Dataset Description
1. **Birds' Songs Numeric Dataset**: The Birds' Songs Numeric Dataset on Kaggle contains numeric representations of bird songs, aimed at facilitating audio classification tasks. The dataset includes multiple features extracted from the audio files, such as spectral properties and time-domain characteristics, enabling machine learning models to analyze and classify different bird species based on their songs [@fleanend2024birds].

```{r}
# Load the ggplot2 package
library(ggplot2)
library(tidytext)
library(tokenizers)

# Step #1 Data Ingesting into R 
#download datasets, if necessary
# download_kaggle_dataset <- function(dataset, path) {
#   # Check if the kaggle command is available
#   if (system("which kaggle", intern = TRUE) == "") {
#     stop("Kaggle API is not installed or not in PATH. Please install it first.")
#   }
#   
#   # Ensure the destination directory exists
#   if (!dir.exists(path)) {
#     dir.create(path, recursive = TRUE)
#   }
#   
#   # Construct the download command
#   command <- sprintf("kaggle datasets download -d %s -p %s", dataset, path)
#   
#   # Execute the command
#   system(command)
#   
#   # Unzip the downloaded file
#   zipfile <- list.files(path, pattern = "*.zip", full.names = TRUE)
#   if (length(zipfile) > 0) {
#     unzip(zipfile, exdir = path)
#     file.remove(zipfile)
#   }
# }
# 
# download_kaggle_dataset("fleanend/birds-songs-numeric-dataset", "./data/birds")

#Importing Train Data

bird_train <- read.csv("./data/birds/train.csv")
# dim(bird_train)
# head(bird_train,3)

#Importing Test Data 

bird_test <- read.csv("./data/birds/test.csv")
# dim(bird_test)
# head(bird_test,3)

#Data Cleaning and Analysis
column_names <- names(bird_train)
# column_names
# unique(bird_train$species)
# unique(bird_train$genus)
# unique(bird_train$id)

# Plotting in graph to see the distribution and find outlier 
ggplot(bird_train, aes(x = species)) +
  geom_bar() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  labs(x = "Species", y = "Count", title = "Distribution")

#Adding  column Genus and species to make it unique --Train Data
bird_train$gen_spec <- paste(bird_train$genus, bird_train$species, sep = "_")
# unique(bird_train$gen_spec)

#Adding  column Genus and species to make it unique --Test Data
bird_test$gen_spec <- paste(bird_test$genus, bird_test$species, sep = "_")


ggplot(bird_train, aes(x = gen_spec)) +
  geom_bar() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  labs(x = "gen_spec", y = "Count", title = "Distribution")

```

2. **Spambase Dataset**: The Spambase dataset from the UCI Machine Learning Repository contains 4601 instances of emails, with 57 features for classification tasks to determine whether an email is spam (1) or not (0). Features include word and character frequency counts, as well as measures of consecutive capital letters. It is commonly used for building and testing spam detection models [@misc_spambase_94].

```{r}
# Step #1 Data Ingesting into R 
# download the datasets
# download_and_extract_zip <- function(url, dest_dir) {
#   # Ensure the destination directory exists
#   if (!dir.exists(dest_dir)) {
#     dir.create(dest_dir, recursive = TRUE)
#   }
#   
#   # Create a temporary file to hold the downloaded zip file
#   temp_zip <- tempfile(fileext = ".zip")
#   
#   # Download the zip file
#   download.file(url, temp_zip, mode = "wb")
#   
#   # Extract the contents of the zip file
#   unzip(temp_zip, exdir = dest_dir)
#   
#   # Remove the temporary zip file
#   unlink(temp_zip)
# }
# 
# download_and_extract_zip("https://archive.ics.uci.edu/static/public/94/spambase.zip", "./data/spambase")

#Importing Spam Data
spam_data <- read.csv("./data/spambase/spambase.data")
# dim(spam_data)
# head(spam_data,3)
colMax <- function(data) sapply(data, max, na.rm = TRUE)
max_across_columns <- colMax(spam_data)
# max_across_columns # we need to normalize the values 
normalized_data <- scale(spam_data, center = FALSE, scale = apply(spam_data, 2, max) - apply(spam_data, 2, min))

#Importing Names data

spam_names <- readLines("./data/spambase/spambase.names", n = -1, skip = 35)
spam_names_57 <-tail(spam_names,57) # Taking only required columns
# cat(spam_names_57, sep = "\n")
# spam_names_57 
transposed_df <- t(spam_names_57)# Transposing rows to columns
# transposed_df



#Data Cleaning and Analysis
column_names <- names(spam_data)
# column_names
# unique(spam_data$X1)
# unique(spam_data$X0)


# Plotting in graph to see the distribution and find outlier 
ggplot(spam_data, aes(x = X1)) +
  geom_bar() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  labs(x = "Spam Or Not", y = "Count", title = "Distribution")

```

3. **COVID-19 NLP Text Classification Dataset**: The COVID-19 NLP Text Classification dataset on Kaggle consists of tweets related to COVID-19, labeled for sentiment analysis. It includes features like tweet content, sentiment labels (positive, negative, neutral), and additional metadata. This dataset is designed for natural language processing tasks to analyze public sentiment during the pandemic [@datatattle2024covid].

```{r}
# Step #1 Data Ingesting into R 
#download datasets, if necessary

# download_kaggle_dataset("datatattle/covid-19-nlp-text-classification", "./data/covid")

#Importing Train Data
corona_train <- read.csv("./data/covid/Corona_NLP_train.csv")
# dim(corona_train)
# head(corona_train,3)


#Importing Test Data 

corona_test <- read.csv("./data/covid/Corona_NLP_test.csv")
# dim(corona_test)
# head(corona_test,3)



#Data Cleaning and Analysis
column_names <- names(corona_train)
# column_names
# unique(corona_train$Sentiment)
# unique(corona_train$Location)
na_counts <- colSums(is.na(corona_train))
# na_counts


# Load the ggplot2 package
# Plotting in graph to see the distribution and find outlier 
ggplot(corona_train, aes(x = Sentiment)) +
  geom_bar() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  labs(x = "Sentiment", y = "Count", title = "Distribution")

corona_train_limit <- corona_train[, c("OriginalTweet", "Sentiment")]

# print(corona_train_limit)


#install.packages("tidytext")

### Cleaning Steps ##

# Remove URLs

# corona_train_limit$OriginalTweet <- gsub("http\\S+|www\\S+", "", corona_train_limit$OriginalTweet)

# Convert to lower
# corona_train_limit$OriginalTweet <- tolower(corona_train_limit$OriginalTweet)

# Remove Spaces
#corona_train_limit$OriginalTweet <- gsub("\\s+", " ", corona_train_limit$OriginalTweet)

#Remove Special Characters, # and @
#corona_train_limit$OriginalTweet <- gsub("[^a-zA-Z\\s]", "", corona_train_limit$OriginalTweet)
# corona_train_limit$OriginalTweet <- gsub("#\\w+", "", corona_train_limit$OriginalTweet)
# corona_train_limit$OriginalTweet <- gsub("@\\w+", "", corona_train_limit$OriginalTweet)


#Tokenize the tweets


# Word tokenization
# corona_train_limit$OriginalTweet_Token <- tokenize_words(corona_train_limit$OriginalTweet)
# print(corona_train_limit)
```

## Data and Visualization

## Statistical Modeling

# Experiment 2: Selection Bias {#experiment-2}
## Methods

## Analysis and Results

## Data and Visualization

## Statistical Modeling

# Experiment 3: Multicollinearity {#experiment-3}
## Methods

## Analysis and Results

## Data and Visualization

## Statistical Modeling

```{r}

```

# Conclusion

# References



